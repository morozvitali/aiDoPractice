üöÄ –°–µ—Ä—ñ—è –ø—Ä–∏–∫–ª–∞–¥—ñ–≤ –¥–ª—è –ø—Ä–æ–∫–∞—á–∫–∏:
‚úÖ 1. –ó–Ω–∞–π–¥–∏ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ª—ñ–≤, —â–æ –º—ñ—Å—Ç—è—Ç—å –±—ñ–ª—å—à–µ –Ω—ñ–∂ 3 –ª—ñ—Ç–µ—Ä–∏

String[] words = {"hi", "java", "code", "fun", "stream"};
–†–µ–∑—É–ª—å—Ç–∞—Ç: 3

‚úÖ 2. –ó–Ω–∞–π–¥–∏ –Ω–∞–π–∫–æ—Ä–æ—Ç—à–µ —Å–ª–æ–≤–æ, —è–∫–µ –ø–æ—á–∏–Ω–∞—î—Ç—å—Å—è –Ω–∞ "s"

String[] words = {String[] words = {"sun", "sand", "sky", "snow", "start", "sea"};
–†–µ–∑—É–ª—å—Ç–∞—Ç: "sea"

‚úÖ 3. –ó–Ω–∞–π–¥–∏ —Å—É–º—É –∫–≤–∞–¥—Ä–∞—Ç—ñ–≤ –Ω–µ–ø–∞—Ä–Ω–∏—Ö —á–∏—Å–µ–ª

int[] nums = {1, 2, 3, 4, 5};
–†–µ–∑—É–ª—å—Ç–∞—Ç: 1*1 + 3*3 + 5*5 = 35

‚úÖ 4. –ó–±–µ—Ä–∏ –≤—Å—ñ —Å–ª–æ–≤–∞ —É –≤–µ—Ä—Ö–Ω—å–æ–º—É —Ä–µ–≥—ñ—Å—Ç—Ä—ñ, —è–∫—ñ –º–∞—é—Ç—å –¥–æ–≤–∂–∏–Ω—É 4

String[] words = {"java", "code", "fun", "javafx", "loop"};
–†–µ–∑—É–ª—å—Ç–∞—Ç: [JAVA, CODE, LOOP]

‚úÖ 5. –°—Ç–≤–æ—Ä–∏ Map<String, Integer>, –¥–µ –∫–ª—é—á ‚Äî —Å–ª–æ–≤–æ, –∞ –∑–Ω–∞—á–µ–Ω–Ω—è ‚Äî –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≥–æ–ª–æ—Å–Ω–∏—Ö

String[] words = {"apple", "banana", "cherry"};
–†–µ–∑—É–ª—å—Ç–∞—Ç:

{
apple=2,
banana=3,
cherry=2
}

üìå –ü–æ—Ä–∞—Ö—É–π—Ç–µ –≥–æ–ª–æ—Å–Ω—ñ —á–µ—Ä–µ–∑ .filter(...) + count() –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ map


I debug with a duck. If it quacks, it‚Äôs probably business logic.
Some ducks just want to be mapped. Others want to be immutable.
Behind every stream that quacks, there might be a mock duck with a lambda.
In Java, even a duck has to implement an interface to quack properly.
AssertEquals("quack", duck.stream().findFirst().get())
This isn‚Äôt a bug. It‚Äôs an abstract duck factory.
This Java stream returns a value that quacks. Don‚Äôt question it ‚Äî just collect.